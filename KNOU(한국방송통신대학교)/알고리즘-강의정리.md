# 알고리즘

## 분할정복 알고리즘

### 분할정복 방법의 원리 
1. 순환적으로 문제를 푸는 하향식 접근 방법 
2. 분할-정복-결합

### 이진 탐색
1. 정렬된 상태의 데이터를 절반씩 줄여가면서 원하는 값을 찾는 방법 
  - T(n) = T(n/2)+Θ(1), T(1) = Θ(1) -> Θ(logn)
  - 정렬되어 있는 데이터를 반으로 나누어 찾아야 할 데이터보다 작으면 오른쪽을, 크면 왼쪽을 남기고 나머지 부분을 버린다. 
  - 찾고 있는 데이터가 나올때까지 과정을 반복한다.
  - 정렬된 데이터에서만 적용 가능하다. 
  - 삽입/삭제가 빈번한 응용에는 부적합하다. 

### 퀵 정렬
1. 왼쪽 부분배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값 
2. 분할 함수 Partition() > 주어진 배열을 두 부분배열로 나누는 함수 
3. 성능
  - 최악의 경우 : T(n) = T(n-1)+Θ(n), T(1)=Θ(1) >> O(n^2)
  - 최선의 경우 : T(n) = 2T(n/2)+ Θ(n), T(1) = Θ(1) >> O(nlogn)
  - 평균적인 경우 : O(nlogn)
4. 특징 : 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 높음 

### 합병 정렬
  1. 같은 크기의 두 부분배열로 분할하고 순환 호출하여 정렬 + 정렬된 두 부분배열을 합쳐서 하나의 정렬 배열을 만듦 
    1) 합병 함수 Merge() -> 정렬된 두 부분배열을 하나의 정렬 배열로 만드는 함수 
    2) 성능 : T(n)=2T(n/2)+Θ(n), T(1)=Θ(1) -> O(nlogn)
    3) 입력 크기 n만큼의 추가적인 저장 장소 필요 

### 선택 문제 
  1. 임의의 순서로 주어진 n개의 원소에서 i번째로 작은 원소를 찾는 문제 
  2. 최솟값/최댓값 찾기 
    1) 최소값 찾기 -> 적어도 (n-1)번의 비교 -> O(n)
    2) 최솟값과 최대값 한번에 모두 찾기 -> 3n/2-2번 비교 -> O(n)
  3. 선택 문제 알고리즘
    1) 퀵 정렬의 Partition() 이용 -> 최악 O(n^2), 평균 O(n)
    2) "중간값들의 중간값" 이용 -> 최악 O(n), 평균 O(n)


## 동적 프로그래밍 알고리즘 

### 동적 프로그래밍 알고리즘의 원리
- 문제의 크기가 작은 소문제에 대한 해를 저장해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식 접근 방법
- 동적 "프로그래밍" ("동적 계획법")  : 컴퓨터에서의 프로그램과 무관 -> 해를 구축하는 테이블을 이용한다. 
- 최적화 문제 (최솟값/최댓값을 구하는 문제)에 적용한다. 

### 분할 정복 방법과 동적 프로그래밍 방법의 차이 
| 분할정복방법 | 동적프로그래밍방법 |
|:---:|:---:|
|하향식 접근 방법 | 상향식 접근 방법|
|상위 레벨의 큰 문제를 순환적으로 부분배열로 분할하고, 이들의 해를 결합해서 원래 문제를 해결하는 방법 | 입력 크기가 작은 소문제들을 모두 해결하여 구한 해를 테이블에 저장한 후, 이 해들을 이용하여 보다 큰 크기의 문제를 해결하는 방법|
|분할된 작은 문제들은 서로 독립적|소문제들은 서로 독립적이지 않고, 중복되는 부분이 존재 
|이진탐색, 합병정렬, 퀵정렬, 선택 문제| 피보나치 수열, 연쇄 행렬 곱셈, 스트링 편집 거리, 모든 정점 간의 최단 경로(플로이드 알고리즘), 저울문제|

### 동적 프로그래밍 방법을 적용하려면 
- 최적성의 원리 (principle of optimality)를 반드시 만족해야 한다. 
- "주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 최적해로 구성된다."

### 동적 프로그래밍 방법의 적용 과정 
0. 문제의 특성을 분석하여 최적성의 원리가 성립되는지 확인 
1. 주어진 문제에 대해서 최적해를 제공하는 점화식을 도출 
2. 가장 작은 소문제부터 점화식의 해를 구해서 테이블에 저장 
3. 테이블에 저장된 소문제의 해를 이용하여 점차적으로 큰 상위 문제의 해를 구함 

#### 피보나치 수열 문제 
f(n) = f(n-1) + f(n-2), n>= 2 , f(0) = 0, f(1) = 1


